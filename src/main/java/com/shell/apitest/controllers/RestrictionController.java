/*
 * ShellCardManagementAPIsLib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

package com.shell.apitest.controllers;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.shell.apitest.ApiHelper;
import com.shell.apitest.Server;
import com.shell.apitest.exceptions.ApiException;
import com.shell.apitest.exceptions.ErrorObjectException;
import com.shell.apitest.http.request.HttpMethod;
import com.shell.apitest.models.AccountRestrictionRequest;
import com.shell.apitest.models.AccountRestrictionResponse;
import com.shell.apitest.models.CreateBundleRequest;
import com.shell.apitest.models.CreateBundleResponse;
import com.shell.apitest.models.DeleteBundleRequest;
import com.shell.apitest.models.DeleteBundleResponse;
import com.shell.apitest.models.RestrictionCardRequest;
import com.shell.apitest.models.RestrictionCardResponse;
import com.shell.apitest.models.RestrictionSearchCardRequest;
import com.shell.apitest.models.RestrictionSearchCardResponse;
import com.shell.apitest.models.SearchAccountLimitRequest;
import com.shell.apitest.models.SearchAccountLimitResponse;
import com.shell.apitest.models.SummaryOfBundleRequest;
import com.shell.apitest.models.SummaryOfBundleResponse;
import com.shell.apitest.models.UpdateBundleRequest;
import com.shell.apitest.models.UpdateBundleResponse;
import io.apimatic.core.ApiCall;
import io.apimatic.core.ErrorCase;
import io.apimatic.core.GlobalConfiguration;
import java.io.IOException;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionException;

/**
 * This class lists all the endpoints of the groups.
 */
public final class RestrictionController extends BaseController {

    /**
     * Initializes the controller.
     * @param globalConfig    Configurations added in client.
     */
    public RestrictionController(GlobalConfiguration globalConfig) {
        super(globalConfig);
    }

    /**
     * This API enables clients to create a new card bundle and apply restrictions. #### Supported
     * operations * Create bundle and include mandatory - * Usage, day/time, product and location
     * restrictions * List of cards to add to bundle * Create bundle and include optional identifier
     * of bundle in external system #### Validation rules The following are the key validation rules
     * with the associated error codes for failed validation- * `7012` - At least one card must be
     * added to the bundle * `7011` - The total number of cards passed in the input must be 500 or
     * less. * `7014` - All the cards passed in the input are part of the selected account. * `7013`
     * - At least one restriction must be applied to the bundle i.e. either of usage, day/time,
     * location or product restriction. * `7005` - Day time restriction cannot be set to restrict
     * the use of a card on all days of the week. * `7000` - Usage restriction of the bundle is not
     * open ended i.e. all the limits within the usage restriction must not be set to 0/null. *
     * `7004` - In the usage restrictions, the limits per transaction should be less than or equal
     * to Daily, Daily should be less than or equal to Weekly, Weekly should be less than or equal
     * to Monthly. Exception being 0/blank will be skipped, i.e. Daily value should be less than
     * equal to Monthly value if Weekly value is 0/blank. * `0007` - Error returned if request
     * parameters fail validation e.g. mandatory check.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: Create Bundle Request body
     * @return    Returns the CreateBundleResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public CreateBundleResponse restrictionBundleCreate(
            final String requestId,
            final CreateBundleRequest body) throws ApiException, IOException {
        return prepareRestrictionBundleCreateRequest(requestId, body).execute();
    }

    /**
     * This API enables clients to create a new card bundle and apply restrictions. #### Supported
     * operations * Create bundle and include mandatory - * Usage, day/time, product and location
     * restrictions * List of cards to add to bundle * Create bundle and include optional identifier
     * of bundle in external system #### Validation rules The following are the key validation rules
     * with the associated error codes for failed validation- * `7012` - At least one card must be
     * added to the bundle * `7011` - The total number of cards passed in the input must be 500 or
     * less. * `7014` - All the cards passed in the input are part of the selected account. * `7013`
     * - At least one restriction must be applied to the bundle i.e. either of usage, day/time,
     * location or product restriction. * `7005` - Day time restriction cannot be set to restrict
     * the use of a card on all days of the week. * `7000` - Usage restriction of the bundle is not
     * open ended i.e. all the limits within the usage restriction must not be set to 0/null. *
     * `7004` - In the usage restrictions, the limits per transaction should be less than or equal
     * to Daily, Daily should be less than or equal to Weekly, Weekly should be less than or equal
     * to Monthly. Exception being 0/blank will be skipped, i.e. Daily value should be less than
     * equal to Monthly value if Weekly value is 0/blank. * `0007` - Error returned if request
     * parameters fail validation e.g. mandatory check.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: Create Bundle Request body
     * @return    Returns the CreateBundleResponse response from the API call
     */
    public CompletableFuture<CreateBundleResponse> restrictionBundleCreateAsync(
            final String requestId,
            final CreateBundleRequest body) {
        try { 
            return prepareRestrictionBundleCreateRequest(requestId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for restrictionBundleCreate.
     */
    private ApiCall<CreateBundleResponse, ApiException> prepareRestrictionBundleCreateRequest(
            final String requestId,
            final CreateBundleRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<CreateBundleResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/card-restrictions/v1/bundles/create")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .headerParam(param -> param.key("RequestId")
                                .value(requestId).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("BearerToken"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, CreateBundleResponse.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing).\n",
                                (reason, context) -> new ErrorObjectException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("The request has not been applied because it lacks valid  authentication credentials for the target resource.\n",
                                (reason, context) -> new ErrorObjectException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("Forbidden",
                                (reason, context) -> new ErrorObjectException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("The origin server did not find a current representation  for the target resource or is not willing to disclose  that one exists.\n",
                                (reason, context) -> new ErrorObjectException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("The server encountered an unexpected condition that  prevented it from fulfilling the request.\n",
                                (reason, context) -> new ErrorObjectException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * This API enables clients to update an existing card bundle and its associated restrictions.
     * #### Supported operations * Add new cards to an existing bundle * Remove cards from existing
     * bundle * Update restrictions applied to existing bundle The following are the key validation
     * rules with the associated error codes for failed validation- #### Validation rules * `9007` -
     * The cards must exist in the cards platform for adding or removing cards. * `7014` - All the
     * cards passed in the input are part of the selected account. * `7018` - All the cards passed
     * in the input are part of the selected bundle. * `7011` - The total number of cards passed in
     * the input must be 500 or less. * `7012` - The action to remove cards should not result in
     * removing all the cards from the bundle. * `7016` - At least one restriction must be modified
     * for â€œUpdateâ€ request action. * `7013` - All restrictions cannot be marked for â€œResetâ€
     * for â€œUpdateâ€ request action. * `7005` - Day time restriction cannot be set to restrict the
     * use of a card on all days of the week. This validation is applicable for Update request
     * action. * `7000` - Usage restriction of the bundle is not open ended i.e., all the limits
     * within the usage restriction must not be set to 0/null. This validation is applicable for
     * Update request action. * `7004` - In the usage restrictions, the limits per transaction
     * should be less than or equal to Daily, Daily should be less than or equal to Weekly, Weekly
     * should be less than or equal to Monthly. Exception being 0/blank will be skipped, i.e., Daily
     * value should be less than equal to Monthly value if Weekly value is 0/blank. This validation
     * is applicable for Update request action. * `0007` - Error returned if request parameters fail
     * validation e.g. at least one card must be provided in the input.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: Update Bundle Request body
     * @return    Returns the UpdateBundleResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public UpdateBundleResponse restrictionBundleUpdate(
            final String requestId,
            final UpdateBundleRequest body) throws ApiException, IOException {
        return prepareRestrictionBundleUpdateRequest(requestId, body).execute();
    }

    /**
     * This API enables clients to update an existing card bundle and its associated restrictions.
     * #### Supported operations * Add new cards to an existing bundle * Remove cards from existing
     * bundle * Update restrictions applied to existing bundle The following are the key validation
     * rules with the associated error codes for failed validation- #### Validation rules * `9007` -
     * The cards must exist in the cards platform for adding or removing cards. * `7014` - All the
     * cards passed in the input are part of the selected account. * `7018` - All the cards passed
     * in the input are part of the selected bundle. * `7011` - The total number of cards passed in
     * the input must be 500 or less. * `7012` - The action to remove cards should not result in
     * removing all the cards from the bundle. * `7016` - At least one restriction must be modified
     * for â€œUpdateâ€ request action. * `7013` - All restrictions cannot be marked for â€œResetâ€
     * for â€œUpdateâ€ request action. * `7005` - Day time restriction cannot be set to restrict the
     * use of a card on all days of the week. This validation is applicable for Update request
     * action. * `7000` - Usage restriction of the bundle is not open ended i.e., all the limits
     * within the usage restriction must not be set to 0/null. This validation is applicable for
     * Update request action. * `7004` - In the usage restrictions, the limits per transaction
     * should be less than or equal to Daily, Daily should be less than or equal to Weekly, Weekly
     * should be less than or equal to Monthly. Exception being 0/blank will be skipped, i.e., Daily
     * value should be less than equal to Monthly value if Weekly value is 0/blank. This validation
     * is applicable for Update request action. * `0007` - Error returned if request parameters fail
     * validation e.g. at least one card must be provided in the input.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: Update Bundle Request body
     * @return    Returns the UpdateBundleResponse response from the API call
     */
    public CompletableFuture<UpdateBundleResponse> restrictionBundleUpdateAsync(
            final String requestId,
            final UpdateBundleRequest body) {
        try { 
            return prepareRestrictionBundleUpdateRequest(requestId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for restrictionBundleUpdate.
     */
    private ApiCall<UpdateBundleResponse, ApiException> prepareRestrictionBundleUpdateRequest(
            final String requestId,
            final UpdateBundleRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<UpdateBundleResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/card-restrictions/v1/bundles/update")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .headerParam(param -> param.key("RequestId")
                                .value(requestId).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("BearerToken"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, UpdateBundleResponse.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing).\n",
                                (reason, context) -> new ErrorObjectException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("The request has not been applied because it lacks valid  authentication credentials for the target resource.\n",
                                (reason, context) -> new ErrorObjectException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("Forbidden",
                                (reason, context) -> new ErrorObjectException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("The origin server did not find a current representation  for the target resource or is not willing to disclose  that one exists.\n",
                                (reason, context) -> new ErrorObjectException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("The server encountered an unexpected condition that  prevented it from fulfilling the request.\n",
                                (reason, context) -> new ErrorObjectException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * This API enables clients to delete an existing card bundle in the Shell Card Platform. Once
     * the card bundle is deleted the usage and product restrictions of the cards that were present
     * in the bundle will be reset based on the request. #### Supported operations * Delete card
     * bundle by bundle Id #### Validation rules The following are the key validation rules with the
     * associated error codes for failed validation- * `7019` - The given card bundle is not
     * available in the Shell Card Platform. * `0007` - Error returned if request parameters fail
     * validation e.g. mandatory check.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: Delete Bundle Request body
     * @return    Returns the DeleteBundleResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public DeleteBundleResponse restrictionBundleDelete(
            final String requestId,
            final DeleteBundleRequest body) throws ApiException, IOException {
        return prepareRestrictionBundleDeleteRequest(requestId, body).execute();
    }

    /**
     * This API enables clients to delete an existing card bundle in the Shell Card Platform. Once
     * the card bundle is deleted the usage and product restrictions of the cards that were present
     * in the bundle will be reset based on the request. #### Supported operations * Delete card
     * bundle by bundle Id #### Validation rules The following are the key validation rules with the
     * associated error codes for failed validation- * `7019` - The given card bundle is not
     * available in the Shell Card Platform. * `0007` - Error returned if request parameters fail
     * validation e.g. mandatory check.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: Delete Bundle Request body
     * @return    Returns the DeleteBundleResponse response from the API call
     */
    public CompletableFuture<DeleteBundleResponse> restrictionBundleDeleteAsync(
            final String requestId,
            final DeleteBundleRequest body) {
        try { 
            return prepareRestrictionBundleDeleteRequest(requestId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for restrictionBundleDelete.
     */
    private ApiCall<DeleteBundleResponse, ApiException> prepareRestrictionBundleDeleteRequest(
            final String requestId,
            final DeleteBundleRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<DeleteBundleResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/card-restrictions/v1/bundles/delete")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .headerParam(param -> param.key("RequestId")
                                .value(requestId).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("BearerToken"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, DeleteBundleResponse.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing).\n",
                                (reason, context) -> new ErrorObjectException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("The request has not been applied because it lacks valid  authentication credentials for the target resource.\n",
                                (reason, context) -> new ErrorObjectException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("Forbidden",
                                (reason, context) -> new ErrorObjectException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("The origin server did not find a current representation  for the target resource or is not willing to disclose  that one exists.\n",
                                (reason, context) -> new ErrorObjectException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("The server encountered an unexpected condition that  prevented it from fulfilling the request.\n",
                                (reason, context) -> new ErrorObjectException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * This API allows clients to get a summary of card bundles associated with Payer/Account. This
     * API will return the basic bundle details including card and restriction details. Optionally
     * the API will also include a count of cards that are not associated with the bundle but
     * returned by the search criteria. Note - to include count of cards of an account that are not
     * associated with any bundles, in the input parameter SearchCardBundles either pass all the
     * bundles of the account in the list or pass only account with bundle id left blank/null. ####
     * Supported operations * Get summary of bundles by list of bundle Ids.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: Summary Bundle Request body
     * @return    Returns the SummaryOfBundleResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public SummaryOfBundleResponse restrictionBundleSummary(
            final String requestId,
            final SummaryOfBundleRequest body) throws ApiException, IOException {
        return prepareRestrictionBundleSummaryRequest(requestId, body).execute();
    }

    /**
     * This API allows clients to get a summary of card bundles associated with Payer/Account. This
     * API will return the basic bundle details including card and restriction details. Optionally
     * the API will also include a count of cards that are not associated with the bundle but
     * returned by the search criteria. Note - to include count of cards of an account that are not
     * associated with any bundles, in the input parameter SearchCardBundles either pass all the
     * bundles of the account in the list or pass only account with bundle id left blank/null. ####
     * Supported operations * Get summary of bundles by list of bundle Ids.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: Summary Bundle Request body
     * @return    Returns the SummaryOfBundleResponse response from the API call
     */
    public CompletableFuture<SummaryOfBundleResponse> restrictionBundleSummaryAsync(
            final String requestId,
            final SummaryOfBundleRequest body) {
        try { 
            return prepareRestrictionBundleSummaryRequest(requestId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for restrictionBundleSummary.
     */
    private ApiCall<SummaryOfBundleResponse, ApiException> prepareRestrictionBundleSummaryRequest(
            final String requestId,
            final SummaryOfBundleRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<SummaryOfBundleResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/card-restrictions/v1/bundles/Summary")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .headerParam(param -> param.key("RequestId")
                                .value(requestId).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("BearerToken"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, SummaryOfBundleResponse.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing).\n",
                                (reason, context) -> new ErrorObjectException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("The request has not been applied because it lacks valid  authentication credentials for the target resource.\n",
                                (reason, context) -> new ErrorObjectException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("Forbidden",
                                (reason, context) -> new ErrorObjectException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("The origin server did not find a current representation  for the target resource or is not willing to disclose  that one exists.\n",
                                (reason, context) -> new ErrorObjectException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("The server encountered an unexpected condition that  prevented it from fulfilling the request.\n",
                                (reason, context) -> new ErrorObjectException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * This API allows to set or update the restrictions for existing cards or newly ordered cards
     * under the same payer. #### Supported operations * Set or reset usage restrictions for cards *
     * Set or reset day/time restrictions for cards * Set or reset product restrictions for cards *
     * Set or reset location restrictions for cards.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: Summary Bundle Request body
     * @return    Returns the RestrictionCardResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public RestrictionCardResponse cardRestriction(
            final String requestId,
            final RestrictionCardRequest body) throws ApiException, IOException {
        return prepareCardRestrictionRequest(requestId, body).execute();
    }

    /**
     * This API allows to set or update the restrictions for existing cards or newly ordered cards
     * under the same payer. #### Supported operations * Set or reset usage restrictions for cards *
     * Set or reset day/time restrictions for cards * Set or reset product restrictions for cards *
     * Set or reset location restrictions for cards.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: Summary Bundle Request body
     * @return    Returns the RestrictionCardResponse response from the API call
     */
    public CompletableFuture<RestrictionCardResponse> cardRestrictionAsync(
            final String requestId,
            final RestrictionCardRequest body) {
        try { 
            return prepareCardRestrictionRequest(requestId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for cardRestriction.
     */
    private ApiCall<RestrictionCardResponse, ApiException> prepareCardRestrictionRequest(
            final String requestId,
            final RestrictionCardRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<RestrictionCardResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/card-restrictions/v2/card")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .headerParam(param -> param.key("RequestId")
                                .value(requestId).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("BearerToken"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, RestrictionCardResponse.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing).\n",
                                (reason, context) -> new ErrorObjectException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("The request has not been applied because it lacks valid  authentication credentials for the target resource.\n",
                                (reason, context) -> new ErrorObjectException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("Forbidden",
                                (reason, context) -> new ErrorObjectException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("The origin server did not find a current representation  for the target resource or is not willing to disclose  that one exists.\n",
                                (reason, context) -> new ErrorObjectException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("The server encountered an unexpected condition that  prevented it from fulfilling the request.\n",
                                (reason, context) -> new ErrorObjectException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * This operation allows setting or updating the usage restrictions of an existing account. ####
     * Validation rules *	The account exists. *	Day time restriction cannot be set to restrict the
     * use of a card, under the account, on all days of the week. *	Either of the usage, daytime or
     * location is either marked for reset or new restriction values provided for the account. *	In
     * usage restrictions, the limits per transaction should be less than or equal to Daily, Daily
     * should be less than or equal to Weekly, Weekly should be less than or equal to Monthly.
     * Exception being 0/blank will be skipped, i.e., Daily value should be less than equal to
     * Monthly value if Weekly value is 0/blank.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: Summary Bundle Request body
     * @return    Returns the AccountRestrictionResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public AccountRestrictionResponse accountRestriction(
            final String requestId,
            final AccountRestrictionRequest body) throws ApiException, IOException {
        return prepareAccountRestrictionRequest(requestId, body).execute();
    }

    /**
     * This operation allows setting or updating the usage restrictions of an existing account. ####
     * Validation rules *	The account exists. *	Day time restriction cannot be set to restrict the
     * use of a card, under the account, on all days of the week. *	Either of the usage, daytime or
     * location is either marked for reset or new restriction values provided for the account. *	In
     * usage restrictions, the limits per transaction should be less than or equal to Daily, Daily
     * should be less than or equal to Weekly, Weekly should be less than or equal to Monthly.
     * Exception being 0/blank will be skipped, i.e., Daily value should be less than equal to
     * Monthly value if Weekly value is 0/blank.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: Summary Bundle Request body
     * @return    Returns the AccountRestrictionResponse response from the API call
     */
    public CompletableFuture<AccountRestrictionResponse> accountRestrictionAsync(
            final String requestId,
            final AccountRestrictionRequest body) {
        try { 
            return prepareAccountRestrictionRequest(requestId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for accountRestriction.
     */
    private ApiCall<AccountRestrictionResponse, ApiException> prepareAccountRestrictionRequest(
            final String requestId,
            final AccountRestrictionRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<AccountRestrictionResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/card-restrictions/v1/Account")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .headerParam(param -> param.key("RequestId")
                                .value(requestId).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("BearerToken"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, AccountRestrictionResponse.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing).\n",
                                (reason, context) -> new ErrorObjectException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("The request has not been applied because it lacks valid  authentication credentials for the target resource.\n",
                                (reason, context) -> new ErrorObjectException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("Forbidden",
                                (reason, context) -> new ErrorObjectException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("The origin server did not find a current representation  for the target resource or is not willing to disclose  that one exists.\n",
                                (reason, context) -> new ErrorObjectException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("The server encountered an unexpected condition that  prevented it from fulfilling the request.\n",
                                (reason, context) -> new ErrorObjectException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * This operation will allow user to get account level limits for the given account. It returns
     * the velocity limits if its overridden at the account else the values will be null/empty.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: Summary Bundle Request body
     * @return    Returns the SearchAccountLimitResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public SearchAccountLimitResponse searchAccountLimit(
            final String requestId,
            final SearchAccountLimitRequest body) throws ApiException, IOException {
        return prepareSearchAccountLimitRequest(requestId, body).execute();
    }

    /**
     * This operation will allow user to get account level limits for the given account. It returns
     * the velocity limits if its overridden at the account else the values will be null/empty.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: Summary Bundle Request body
     * @return    Returns the SearchAccountLimitResponse response from the API call
     */
    public CompletableFuture<SearchAccountLimitResponse> searchAccountLimitAsync(
            final String requestId,
            final SearchAccountLimitRequest body) {
        try { 
            return prepareSearchAccountLimitRequest(requestId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for searchAccountLimit.
     */
    private ApiCall<SearchAccountLimitResponse, ApiException> prepareSearchAccountLimitRequest(
            final String requestId,
            final SearchAccountLimitRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<SearchAccountLimitResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/card-restrictions/v1/searchaccountlimit")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .headerParam(param -> param.key("RequestId")
                                .value(requestId).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("BearerToken"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, SearchAccountLimitResponse.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing).\n",
                                (reason, context) -> new ErrorObjectException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("The request has not been applied because it lacks valid  authentication credentials for the target resource.\n",
                                (reason, context) -> new ErrorObjectException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("Forbidden",
                                (reason, context) -> new ErrorObjectException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("The origin server did not find a current representation  for the target resource or is not willing to disclose  that one exists.\n",
                                (reason, context) -> new ErrorObjectException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("The server encountered an unexpected condition that  prevented it from fulfilling the request.\n",
                                (reason, context) -> new ErrorObjectException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * This API will allows querying card details including the day/time and product restrictions.
     * #### Supported operations * Search by list of cards or bundle * Include card bundle details
     * (optional).
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: Summary Bundle Request body
     * @return    Returns the RestrictionSearchCardResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public RestrictionSearchCardResponse searchCardRestriction(
            final String requestId,
            final RestrictionSearchCardRequest body) throws ApiException, IOException {
        return prepareSearchCardRestrictionRequest(requestId, body).execute();
    }

    /**
     * This API will allows querying card details including the day/time and product restrictions.
     * #### Supported operations * Search by list of cards or bundle * Include card bundle details
     * (optional).
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: Summary Bundle Request body
     * @return    Returns the RestrictionSearchCardResponse response from the API call
     */
    public CompletableFuture<RestrictionSearchCardResponse> searchCardRestrictionAsync(
            final String requestId,
            final RestrictionSearchCardRequest body) {
        try { 
            return prepareSearchCardRestrictionRequest(requestId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for searchCardRestriction.
     */
    private ApiCall<RestrictionSearchCardResponse, ApiException> prepareSearchCardRestrictionRequest(
            final String requestId,
            final RestrictionSearchCardRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<RestrictionSearchCardResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/card-restrictions/v2/search")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .headerParam(param -> param.key("RequestId")
                                .value(requestId).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("BearerToken"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, RestrictionSearchCardResponse.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing).\n",
                                (reason, context) -> new ErrorObjectException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("The request has not been applied because it lacks valid  authentication credentials for the target resource.\n",
                                (reason, context) -> new ErrorObjectException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("Forbidden",
                                (reason, context) -> new ErrorObjectException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("The origin server did not find a current representation  for the target resource or is not willing to disclose  that one exists.\n",
                                (reason, context) -> new ErrorObjectException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("The server encountered an unexpected condition that  prevented it from fulfilling the request.\n",
                                (reason, context) -> new ErrorObjectException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }
}