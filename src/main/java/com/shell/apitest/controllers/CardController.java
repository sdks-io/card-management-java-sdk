/*
 * ShellCardManagementAPIsLib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

package com.shell.apitest.controllers;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.shell.apitest.ApiHelper;
import com.shell.apitest.Server;
import com.shell.apitest.exceptions.ApiException;
import com.shell.apitest.exceptions.ErrorObjectException;
import com.shell.apitest.http.request.HttpMethod;
import com.shell.apitest.models.AutoRenewCardRequest;
import com.shell.apitest.models.AutoRenewCardResponse;
import com.shell.apitest.models.CancelCardResponse;
import com.shell.apitest.models.CardDetailsRequest;
import com.shell.apitest.models.CardDetailsResponse;
import com.shell.apitest.models.CardManagementV1CancelRequest;
import com.shell.apitest.models.CardManagementV1OrdercardRequest;
import com.shell.apitest.models.CardManagementV1PinreminderRequest;
import com.shell.apitest.models.CardManagementV1UpdatestatusRequest;
import com.shell.apitest.models.CardMoveRequest;
import com.shell.apitest.models.CardMoveResponse;
import com.shell.apitest.models.CardSearchResponse;
import com.shell.apitest.models.CardSummaryRequest;
import com.shell.apitest.models.CardSummaryResponse;
import com.shell.apitest.models.DeliveryAddressUpdateRequest;
import com.shell.apitest.models.DeliveryAddressUpdateResponse;
import com.shell.apitest.models.GeneratePINKeyResponse;
import com.shell.apitest.models.OrderCardEnquiryRequest;
import com.shell.apitest.models.OrderCardEnquiryResponse;
import com.shell.apitest.models.OrderCardResponse;
import com.shell.apitest.models.PINReminderResponse;
import com.shell.apitest.models.PurchaseCategoryRequest;
import com.shell.apitest.models.PurchaseCategoryResponse;
import com.shell.apitest.models.ScheduleCardBlockRequest;
import com.shell.apitest.models.ScheduleCardBlockResponse;
import com.shell.apitest.models.SearchCardRequest;
import com.shell.apitest.models.UpdateCardStatusResponse;
import com.shell.apitest.models.UpdateMPayRegStatusRequest;
import com.shell.apitest.models.UpdateMPayRegStatusResponse;
import io.apimatic.core.ApiCall;
import io.apimatic.core.ErrorCase;
import io.apimatic.core.GlobalConfiguration;
import java.io.IOException;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionException;

/**
 * This class lists all the endpoints of the groups.
 */
public final class CardController extends BaseController {

    /**
     * Initializes the controller.
     * @param globalConfig    Configurations added in client.
     */
    public CardController(GlobalConfiguration globalConfig) {
        super(globalConfig);
    }

    /**
     * This API allows to search for Shell Cards in the Shell Card Platform. It provides flexible
     * search criteria and supports paging. #### New version updates * Oauth authentication to
     * access the API * New parameters have been added in the response. Below are the list of
     * parameters added * IsEMVContact * IsEMVContactless * IsRFID * RFIDUID * EMAID *
     * EVPrintedNumber * CardMediaCode #### Supported operations * Search cards by card id or PAN *
     * Search cards by card status * Search cards by excluding card status * Search cards by date
     * fields * Search cards by embossed fields * Search cards by card configuration fields * Search
     * cards by included/excluded list of cards * Search cards by excluding card bundle Id.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: requestbody
     * @return    Returns the CardSearchResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public CardSearchResponse searchCard(
            final String requestId,
            final SearchCardRequest body) throws ApiException, IOException {
        return prepareSearchCardRequest(requestId, body).execute();
    }

    /**
     * This API allows to search for Shell Cards in the Shell Card Platform. It provides flexible
     * search criteria and supports paging. #### New version updates * Oauth authentication to
     * access the API * New parameters have been added in the response. Below are the list of
     * parameters added * IsEMVContact * IsEMVContactless * IsRFID * RFIDUID * EMAID *
     * EVPrintedNumber * CardMediaCode #### Supported operations * Search cards by card id or PAN *
     * Search cards by card status * Search cards by excluding card status * Search cards by date
     * fields * Search cards by embossed fields * Search cards by card configuration fields * Search
     * cards by included/excluded list of cards * Search cards by excluding card bundle Id.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: requestbody
     * @return    Returns the CardSearchResponse response from the API call
     */
    public CompletableFuture<CardSearchResponse> searchCardAsync(
            final String requestId,
            final SearchCardRequest body) {
        try { 
            return prepareSearchCardRequest(requestId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for searchCard.
     */
    private ApiCall<CardSearchResponse, ApiException> prepareSearchCardRequest(
            final String requestId,
            final SearchCardRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<CardSearchResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.SHELL.value())
                        .path("/card-management/v1/search")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .headerParam(param -> param.key("RequestId")
                                .value(requestId).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("BearerToken"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, CardSearchResponse.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing).",
                                (reason, context) -> new ErrorObjectException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("The request has not been applied because it lacks valid  authentication credentials for the target resource.",
                                (reason, context) -> new ErrorObjectException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("Forbidden",
                                (reason, context) -> new ErrorObjectException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("The origin server did not find a current representation  for the target resource or is not willing to disclose  that one exists.",
                                (reason, context) -> new ErrorObjectException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("The server encountered an unexpected condition that  prevented it from fulfilling the request.",
                                (reason, context) -> new ErrorObjectException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * This API allows to search for fuel cards in the Shell Card Platform and returns a high-level
     * summary count. It provides flexible search criteria. #### New version updates * Oauth
     * authentication to access the API * Minor change in response structure with addition of Status
     * parameter #### Supported operations * Search cards by card id or PAN * Search cards by card
     * status * Search cards by excluding card status * Search cards by date fields * Search cards
     * by embossed fields * Search cards by card configuration fields * Search cards by
     * included/excluded list of cards.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: summary request body
     * @return    Returns the CardSummaryResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public CardSummaryResponse cardSummary(
            final String requestId,
            final CardSummaryRequest body) throws ApiException, IOException {
        return prepareCardSummaryRequest(requestId, body).execute();
    }

    /**
     * This API allows to search for fuel cards in the Shell Card Platform and returns a high-level
     * summary count. It provides flexible search criteria. #### New version updates * Oauth
     * authentication to access the API * Minor change in response structure with addition of Status
     * parameter #### Supported operations * Search cards by card id or PAN * Search cards by card
     * status * Search cards by excluding card status * Search cards by date fields * Search cards
     * by embossed fields * Search cards by card configuration fields * Search cards by
     * included/excluded list of cards.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: summary request body
     * @return    Returns the CardSummaryResponse response from the API call
     */
    public CompletableFuture<CardSummaryResponse> cardSummaryAsync(
            final String requestId,
            final CardSummaryRequest body) {
        try { 
            return prepareCardSummaryRequest(requestId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for cardSummary.
     */
    private ApiCall<CardSummaryResponse, ApiException> prepareCardSummaryRequest(
            final String requestId,
            final CardSummaryRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<CardSummaryResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.SHELL.value())
                        .path("/card-management/v1/summary")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .headerParam(param -> param.key("RequestId")
                                .value(requestId).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("BearerToken"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, CardSummaryResponse.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing).",
                                (reason, context) -> new ErrorObjectException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("The request has not been applied because it lacks valid  authentication credentials for the target resource.",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("Forbidden",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("The origin server did not find a current representation  for the target resource or is not willing to disclose  that one exists.",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("The server encountered an unexpected condition that  prevented it from fulfilling the request.",
                                (reason, context) -> new ErrorObjectException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * This API allows ordering one or more fuel cards (up to 50). If the API call succeeds, the API
     * will return a reference number and queue the request for asynchronous processing. #### New
     * version updates * Oauth authentication to access the API * New parameters have been added in
     * the response for the new PIN management changes. Below parameters needs to be derived from
     * the new PIN encryption method explained in our Mobility Card PIN Management product. *
     * SelfSelectedEncryptedPIN * SelfSelectedPINKeyID * SelfSelectedPINSessionKey * New parameters
     * have been added in the response for card and pin delivery mechanism which gives the
     * opportunity to deliver card &amp; pin by email, SMS or post. Also the possibility to deliver card
     * and pin to different address if the use case demands. * CardDeliveryType *
     * PINDeliveryAddressType * PINAdviceType * PINContact * CardContact #### Supported operations *
     * Order one or more cards (up to 50) * Order card with self selected PIN * Order card with
     * vehicle registration number * Order card and add to new or exisitng card group * Order card
     * and enable fleetId or odemeter input * Order card and specify product groups #### Validation
     * rules * Number of cards per request does not exceed 50 #### API response * A main reference
     * number for the API request (**OrderReference**) * Individual reference numbers
     * (**OrderCardReference**) for each new card.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: Order card request body
     * @return    Returns the OrderCardResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public OrderCardResponse orderCard(
            final String requestId,
            final CardManagementV1OrdercardRequest body) throws ApiException, IOException {
        return prepareOrderCardRequest(requestId, body).execute();
    }

    /**
     * This API allows ordering one or more fuel cards (up to 50). If the API call succeeds, the API
     * will return a reference number and queue the request for asynchronous processing. #### New
     * version updates * Oauth authentication to access the API * New parameters have been added in
     * the response for the new PIN management changes. Below parameters needs to be derived from
     * the new PIN encryption method explained in our Mobility Card PIN Management product. *
     * SelfSelectedEncryptedPIN * SelfSelectedPINKeyID * SelfSelectedPINSessionKey * New parameters
     * have been added in the response for card and pin delivery mechanism which gives the
     * opportunity to deliver card &amp; pin by email, SMS or post. Also the possibility to deliver card
     * and pin to different address if the use case demands. * CardDeliveryType *
     * PINDeliveryAddressType * PINAdviceType * PINContact * CardContact #### Supported operations *
     * Order one or more cards (up to 50) * Order card with self selected PIN * Order card with
     * vehicle registration number * Order card and add to new or exisitng card group * Order card
     * and enable fleetId or odemeter input * Order card and specify product groups #### Validation
     * rules * Number of cards per request does not exceed 50 #### API response * A main reference
     * number for the API request (**OrderReference**) * Individual reference numbers
     * (**OrderCardReference**) for each new card.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: Order card request body
     * @return    Returns the OrderCardResponse response from the API call
     */
    public CompletableFuture<OrderCardResponse> orderCardAsync(
            final String requestId,
            final CardManagementV1OrdercardRequest body) {
        try { 
            return prepareOrderCardRequest(requestId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for orderCard.
     */
    private ApiCall<OrderCardResponse, ApiException> prepareOrderCardRequest(
            final String requestId,
            final CardManagementV1OrdercardRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<OrderCardResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.SHELL.value())
                        .path("/card-management/v1/ordercard")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .headerParam(param -> param.key("RequestId")
                                .value(requestId).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("BearerToken"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, OrderCardResponse.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing).",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("The request has not been applied because it lacks valid  authentication credentials for the target resource.",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("Forbidden",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("The origin server did not find a current representation  for the target resource or is not willing to disclose  that one exists.",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("The server encountered an unexpected condition that  prevented it from fulfilling the request.",
                                (reason, context) -> new ApiException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * This API retrieves the card order status from the Shell Card Platform based on the given
     * reference numbers. #### New version updates * Oauth authentication to access the API * Minor
     * change in response structure with addition of Status parameter #### Supported operations *
     * Get order status by Bulk Card Order Reference * Get order status by Order Reference (main
     * reference for the order) * Get order status by Card Reference (individual card reference
     * belonging to an order reference).
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: Order Card Enquiry request body
     * @return    Returns the OrderCardEnquiryResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public OrderCardEnquiryResponse orderCardEnquiry(
            final String requestId,
            final OrderCardEnquiryRequest body) throws ApiException, IOException {
        return prepareOrderCardEnquiryRequest(requestId, body).execute();
    }

    /**
     * This API retrieves the card order status from the Shell Card Platform based on the given
     * reference numbers. #### New version updates * Oauth authentication to access the API * Minor
     * change in response structure with addition of Status parameter #### Supported operations *
     * Get order status by Bulk Card Order Reference * Get order status by Order Reference (main
     * reference for the order) * Get order status by Card Reference (individual card reference
     * belonging to an order reference).
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: Order Card Enquiry request body
     * @return    Returns the OrderCardEnquiryResponse response from the API call
     */
    public CompletableFuture<OrderCardEnquiryResponse> orderCardEnquiryAsync(
            final String requestId,
            final OrderCardEnquiryRequest body) {
        try { 
            return prepareOrderCardEnquiryRequest(requestId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for orderCardEnquiry.
     */
    private ApiCall<OrderCardEnquiryResponse, ApiException> prepareOrderCardEnquiryRequest(
            final String requestId,
            final OrderCardEnquiryRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<OrderCardEnquiryResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.SHELL.value())
                        .path("/card-management/v1/ordercardenquiry")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .headerParam(param -> param.key("RequestId")
                                .value(requestId).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("BearerToken"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, OrderCardEnquiryResponse.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing).",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("The request has not been applied because it lacks valid  authentication credentials for the target resource.",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("Forbidden",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("The origin server did not find a current representation  for the target resource or is not willing to disclose  that one exists.",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("The server encountered an unexpected condition that  prevented it from fulfilling the request.",
                                (reason, context) -> new ApiException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * This API allows cancelling one or multiple cards (up to 500) within a single API call. This
     * API allows updating of the card to the following status- * Block (Cancelled) #### New version
     * updates * Oauth authentication to access the API * Change in the request body * PIN delivery
     * address details have been added along with Email and Phone number for card and PIN delivery.
     * Requests that passed the below validations are queued- * All Mandatory fields are passed. *
     * Card is present in the Shell Card Platform. * Only one matching card is available in the
     * cards platform for the given PAN and expiry date for Block requests. * Card is allowed to be
     * moved to proposed state as per the card status transition configuration in cards platform. *
     * A valid Reason Id or Reason Text is provided. The reason for card cancellation can be
     * “Damaged” or “NoLongerRequired”. * For the given card, there is no Cancel request already
     * submitted via this API and is being processed. * ‘IsReplacementChargeable’ is set to ‘False’
     * only to the configured customer, other customers need to set it as ‘True’ only. If other
     * customers pass this value as ‘False’. Note- Shell Card Platform will maintain the list of
     * customers, to whom ‘IsReplacementChargeable’ can be set as ‘False’. If all validations are
     * passed, the request will be accepted and the API will return reference numbers for tracking
     * purpose. If any of the validations fail, the API will return the appropriate error details on
     * response. The API response will include- * A main reference number for the API request. * A
     * list of successfully validated and accepted cards along with the individual reference numbers
     * for each of the successful requests. * A list of cards for which at least validation has
     * failed along with the appropriate error code and details. A permanent block (cancelled)
     * request for the card will be queued in Shell Card Platform after the configured damaged card
     * active period (configured as number of days). When a card is requested to be Blocked
     * permanently (cancelled) for which a request has already been submitted to report as Damaged
     * and the damaged card active period is not yet completed, the damaged card request will be
     * marked as superseded and the new Block (cancelled) request will be processed.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: Update status request body
     * @return    Returns the CancelCardResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public CancelCardResponse cardCancel(
            final String requestId,
            final CardManagementV1CancelRequest body) throws ApiException, IOException {
        return prepareCardCancelRequest(requestId, body).execute();
    }

    /**
     * This API allows cancelling one or multiple cards (up to 500) within a single API call. This
     * API allows updating of the card to the following status- * Block (Cancelled) #### New version
     * updates * Oauth authentication to access the API * Change in the request body * PIN delivery
     * address details have been added along with Email and Phone number for card and PIN delivery.
     * Requests that passed the below validations are queued- * All Mandatory fields are passed. *
     * Card is present in the Shell Card Platform. * Only one matching card is available in the
     * cards platform for the given PAN and expiry date for Block requests. * Card is allowed to be
     * moved to proposed state as per the card status transition configuration in cards platform. *
     * A valid Reason Id or Reason Text is provided. The reason for card cancellation can be
     * “Damaged” or “NoLongerRequired”. * For the given card, there is no Cancel request already
     * submitted via this API and is being processed. * ‘IsReplacementChargeable’ is set to ‘False’
     * only to the configured customer, other customers need to set it as ‘True’ only. If other
     * customers pass this value as ‘False’. Note- Shell Card Platform will maintain the list of
     * customers, to whom ‘IsReplacementChargeable’ can be set as ‘False’. If all validations are
     * passed, the request will be accepted and the API will return reference numbers for tracking
     * purpose. If any of the validations fail, the API will return the appropriate error details on
     * response. The API response will include- * A main reference number for the API request. * A
     * list of successfully validated and accepted cards along with the individual reference numbers
     * for each of the successful requests. * A list of cards for which at least validation has
     * failed along with the appropriate error code and details. A permanent block (cancelled)
     * request for the card will be queued in Shell Card Platform after the configured damaged card
     * active period (configured as number of days). When a card is requested to be Blocked
     * permanently (cancelled) for which a request has already been submitted to report as Damaged
     * and the damaged card active period is not yet completed, the damaged card request will be
     * marked as superseded and the new Block (cancelled) request will be processed.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: Update status request body
     * @return    Returns the CancelCardResponse response from the API call
     */
    public CompletableFuture<CancelCardResponse> cardCancelAsync(
            final String requestId,
            final CardManagementV1CancelRequest body) {
        try { 
            return prepareCardCancelRequest(requestId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for cardCancel.
     */
    private ApiCall<CancelCardResponse, ApiException> prepareCardCancelRequest(
            final String requestId,
            final CardManagementV1CancelRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<CancelCardResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.SHELL.value())
                        .path("/card-management/v1/cancel")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .headerParam(param -> param.key("RequestId")
                                .value(requestId).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("BearerToken"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, CancelCardResponse.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing).",
                                (reason, context) -> new ErrorObjectException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("The request has not been applied because it lacks valid  authentication credentials for the target resource.",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("Forbidden",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("The origin server did not find a current representation  for the target resource or is not willing to disclose  that one exists.",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("The server encountered an unexpected condition that  prevented it from fulfilling the request.",
                                (reason, context) -> new ApiException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * This API allows updating of the card status for one or more cards (up to 500) within a single
     * API call. If the API call succeeds, the API will return a reference number and queue the
     * request for asynchronous processing. #### New version updates * Oauth authentication to
     * access the API * Change in the request body * Pin change related parameters -
     * SelfSelectedEncryptedPIN, SelfSelectedPINKeyID, SelfSelectedPINSessionKey * PIN delivery
     * address details have been added along with Email and Phone number for card and PIN delivery.
     * * SaveForPINReminder - The given address will be used for sending PIN reminders in future
     * when requested. * SaveForCardReissue - If this is specified, the contact address will be
     * saved in cards platform for card reissue processing. #### Supported operations * Updating a
     * card status to Temporary block, Unblock, Block (Cancelled) or Damaged * Requesting a
     * replacement card when status is set to Block or Damaged #### Validation rules * Number of
     * cards per request does not exceed 500 * A card can be changed to proposed status as per the
     * card status transition configuration in the Shell Card Platform * Locating a card - * If
     * target status set to **TemporaryBlock**, then only one matching active card should exist in
     * the Shell Card Platform for the given **PAN** and **CardExpiryDate** * If target status set
     * to **Unblock** or **Block**, then only one matching card should exist in the Shell Card
     * Platform for the given **PAN** and **CardExpiryDate** * A valid Reason Id or Reason Text is
     * provided * If target status set to **Block** or **Damaged** and a **ReasonText** is provided,
     * the value must be from the fixed list - *'Lost'*, *'Stolen'* or *'Card no longer required'* *
     * For the given card, there is no Status Update request already submitted via this API and is
     * being processed * The **OrderReplacementCard** field is set to True only for cards with a
     * target status set to Block or Damaged #### API response * A main reference number for the API
     * request (**OrderReplacementReference**) * A list of successfully validated and accepted cards
     * along with the individual reference numbers (**UpdateCardReference**) for each of the
     * successful request * A list of cards (**ErrorCards**) that failed validation along with the
     * appropriate error code and message #### Asynchronous processing of valid API request *
     * Replacement cards * Request for a replacement card will be placed only when the Block card or
     * Block damaged card request is successfully placed. * The Replacement card request will be
     * processed only when the permanent Block card request is successfully processed. In case of
     * damaged card request, the replacement card request will be processed immediately. * Damaged
     * cards * Setting a card to Damaged will automatically trigger a request to permanently block
     * the card. This will only take effect once the ‘Damaged Active’ period has passed. * The
     * Damaged card active period is the number of days after which a "Damaged" card request will be
     * processed. This value is configured at ColCo level. * If a card is reported as damaged at
     * 10pm local time on 1st Nov and the damaged card period is set to 10 days, then the block
     * request will be submitted to the Shell Card Platform on 11th Nov 00-01 local time. * If
     * during the damage card active period another request is made to set the card to Temporarily
     * Blocked or Blocked permanently (cancelled), then the damaged card request will be marked as
     * superseded and the new Temporary Block or Block (cancelled) will be processed.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: Update status request body
     * @return    Returns the UpdateCardStatusResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public UpdateCardStatusResponse cardUpdateStatus(
            final String requestId,
            final CardManagementV1UpdatestatusRequest body) throws ApiException, IOException {
        return prepareCardUpdateStatusRequest(requestId, body).execute();
    }

    /**
     * This API allows updating of the card status for one or more cards (up to 500) within a single
     * API call. If the API call succeeds, the API will return a reference number and queue the
     * request for asynchronous processing. #### New version updates * Oauth authentication to
     * access the API * Change in the request body * Pin change related parameters -
     * SelfSelectedEncryptedPIN, SelfSelectedPINKeyID, SelfSelectedPINSessionKey * PIN delivery
     * address details have been added along with Email and Phone number for card and PIN delivery.
     * * SaveForPINReminder - The given address will be used for sending PIN reminders in future
     * when requested. * SaveForCardReissue - If this is specified, the contact address will be
     * saved in cards platform for card reissue processing. #### Supported operations * Updating a
     * card status to Temporary block, Unblock, Block (Cancelled) or Damaged * Requesting a
     * replacement card when status is set to Block or Damaged #### Validation rules * Number of
     * cards per request does not exceed 500 * A card can be changed to proposed status as per the
     * card status transition configuration in the Shell Card Platform * Locating a card - * If
     * target status set to **TemporaryBlock**, then only one matching active card should exist in
     * the Shell Card Platform for the given **PAN** and **CardExpiryDate** * If target status set
     * to **Unblock** or **Block**, then only one matching card should exist in the Shell Card
     * Platform for the given **PAN** and **CardExpiryDate** * A valid Reason Id or Reason Text is
     * provided * If target status set to **Block** or **Damaged** and a **ReasonText** is provided,
     * the value must be from the fixed list - *'Lost'*, *'Stolen'* or *'Card no longer required'* *
     * For the given card, there is no Status Update request already submitted via this API and is
     * being processed * The **OrderReplacementCard** field is set to True only for cards with a
     * target status set to Block or Damaged #### API response * A main reference number for the API
     * request (**OrderReplacementReference**) * A list of successfully validated and accepted cards
     * along with the individual reference numbers (**UpdateCardReference**) for each of the
     * successful request * A list of cards (**ErrorCards**) that failed validation along with the
     * appropriate error code and message #### Asynchronous processing of valid API request *
     * Replacement cards * Request for a replacement card will be placed only when the Block card or
     * Block damaged card request is successfully placed. * The Replacement card request will be
     * processed only when the permanent Block card request is successfully processed. In case of
     * damaged card request, the replacement card request will be processed immediately. * Damaged
     * cards * Setting a card to Damaged will automatically trigger a request to permanently block
     * the card. This will only take effect once the ‘Damaged Active’ period has passed. * The
     * Damaged card active period is the number of days after which a "Damaged" card request will be
     * processed. This value is configured at ColCo level. * If a card is reported as damaged at
     * 10pm local time on 1st Nov and the damaged card period is set to 10 days, then the block
     * request will be submitted to the Shell Card Platform on 11th Nov 00-01 local time. * If
     * during the damage card active period another request is made to set the card to Temporarily
     * Blocked or Blocked permanently (cancelled), then the damaged card request will be marked as
     * superseded and the new Temporary Block or Block (cancelled) will be processed.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: Update status request body
     * @return    Returns the UpdateCardStatusResponse response from the API call
     */
    public CompletableFuture<UpdateCardStatusResponse> cardUpdateStatusAsync(
            final String requestId,
            final CardManagementV1UpdatestatusRequest body) {
        try { 
            return prepareCardUpdateStatusRequest(requestId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for cardUpdateStatus.
     */
    private ApiCall<UpdateCardStatusResponse, ApiException> prepareCardUpdateStatusRequest(
            final String requestId,
            final CardManagementV1UpdatestatusRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<UpdateCardStatusResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.SHELL.value())
                        .path("/card-management/v1/updatestatus")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .headerParam(param -> param.key("RequestId")
                                .value(requestId).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("BearerToken"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, UpdateCardStatusResponse.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing).",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("The request has not been applied because it lacks valid  authentication credentials for the target resource.",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("Forbidden",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("The origin server did not find a current representation  for the target resource or is not willing to disclose  that one exists.",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("The server encountered an unexpected condition that  prevented it from fulfilling the request.",
                                (reason, context) -> new ApiException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * This API will allow querying the purchase categories of Card for the given country and/or
     * card type. It will also include the below data associated with each of the purchase
     * categories on it’s response. * List of fuel and non-fuel product sets associated. * List of
     * products configured in each product set.
     * @param  apikey  Required parameter: This is the API key of the specific environment which
     *         needs to be passed by the client.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: PurchaseCategory request body
     * @return    Returns the PurchaseCategoryResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public PurchaseCategoryResponse purchaseCategory(
            final String apikey,
            final String requestId,
            final PurchaseCategoryRequest body) throws ApiException, IOException {
        return preparePurchaseCategoryRequest(apikey, requestId, body).execute();
    }

    /**
     * This API will allow querying the purchase categories of Card for the given country and/or
     * card type. It will also include the below data associated with each of the purchase
     * categories on it’s response. * List of fuel and non-fuel product sets associated. * List of
     * products configured in each product set.
     * @param  apikey  Required parameter: This is the API key of the specific environment which
     *         needs to be passed by the client.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: PurchaseCategory request body
     * @return    Returns the PurchaseCategoryResponse response from the API call
     */
    public CompletableFuture<PurchaseCategoryResponse> purchaseCategoryAsync(
            final String apikey,
            final String requestId,
            final PurchaseCategoryRequest body) {
        try { 
            return preparePurchaseCategoryRequest(apikey, requestId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for purchaseCategory.
     */
    private ApiCall<PurchaseCategoryResponse, ApiException> preparePurchaseCategoryRequest(
            final String apikey,
            final String requestId,
            final PurchaseCategoryRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<PurchaseCategoryResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.SHELL.value())
                        .path("/fleetmanagement/v1/master/purchasecategory")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .headerParam(param -> param.key("apikey")
                                .value(apikey).isRequired(false))
                        .headerParam(param -> param.key("RequestId")
                                .value(requestId).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("BearerToken"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, PurchaseCategoryResponse.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("The server cannot or will not process the request  due to something that is perceived to be a client\r\n error (e.g., malformed request syntax, invalid \r\n request message framing, or deceptive request routing).",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("The request has not been applied because it lacks valid  authentication credentials for the target resource.",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("The server understood the request but refuses to authorize it.",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("The origin server did not find a current representation  for the target resource or is not willing to disclose  that one exists.",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("The server encountered an unexpected condition the prevented it from fulfilling the request.",
                                (reason, context) -> new ApiException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * This API allows to fetch details of a single fuel card from the Shell Card Platform. If a
     * **CardId** request parameter is provided, this will return a single card. If a **PAN**
     * request parameter is provided, this may result in multiple fuel cards matching the search
     * criteria. The card details of the most recently issued card will be returned. #### Supported
     * operations * Get card by card id or PAN.
     * @param  apikey  Required parameter: This is the API key of the specific environment which
     *         needs to be passed by the client.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: Card details request body
     * @return    Returns the CardDetailsResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public CardDetailsResponse cardDetails(
            final String apikey,
            final String requestId,
            final CardDetailsRequest body) throws ApiException, IOException {
        return prepareCardDetailsRequest(apikey, requestId, body).execute();
    }

    /**
     * This API allows to fetch details of a single fuel card from the Shell Card Platform. If a
     * **CardId** request parameter is provided, this will return a single card. If a **PAN**
     * request parameter is provided, this may result in multiple fuel cards matching the search
     * criteria. The card details of the most recently issued card will be returned. #### Supported
     * operations * Get card by card id or PAN.
     * @param  apikey  Required parameter: This is the API key of the specific environment which
     *         needs to be passed by the client.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: Card details request body
     * @return    Returns the CardDetailsResponse response from the API call
     */
    public CompletableFuture<CardDetailsResponse> cardDetailsAsync(
            final String apikey,
            final String requestId,
            final CardDetailsRequest body) {
        try { 
            return prepareCardDetailsRequest(apikey, requestId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for cardDetails.
     */
    private ApiCall<CardDetailsResponse, ApiException> prepareCardDetailsRequest(
            final String apikey,
            final String requestId,
            final CardDetailsRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<CardDetailsResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.SHELL.value())
                        .path("/fleetmanagement/v1/card/card")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .headerParam(param -> param.key("apikey")
                                .value(apikey).isRequired(false))
                        .headerParam(param -> param.key("RequestId")
                                .value(requestId).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("BearerToken"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, CardDetailsResponse.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("The server cannot or will not process the request  due to something that is perceived to be a client\r\n error (e.g., malformed request syntax, invalid \r\n request message framing, or deceptive request routing).",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("The request has not been applied because it lacks valid  authentication credentials for the target resource.",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("The server understood the request but refuses to authorize it.",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("The origin server did not find a current representation  for the target resource or is not willing to disclose  that one exists.",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("The server encountered an unexpected condition the prevented it from fulfilling the request.",
                                (reason, context) -> new ApiException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * This API allows to move one or more fuel cards (up to 500) across card groups within a single
     * account or across accounts under the same payer. If the API call succeeds, the API will
     * return a reference number and queue the request for asynchronous processing. #### Supported
     * operations * Moving card to exisitng card group * Moving card to new card group * Removing a
     * card from a card group #### Validation rules * Number of cards per request does not exceed
     * 500 * Given **PAN** for a card matches with only one card * A card is allowed to be moved to
     * the **TargetCardGroupId** or **TargetAccountNumber** * A pending move request does not exist
     * in the queue for a card submitted on the same date (customers local) * A card has not been
     * moved as part of a previous request on the same date (customers local) #### API response * A
     * main reference number for the API request (**MoveCardRequestReference**) * Individual
     * reference numbers (**MoveCardReference**) for each card move request that passes validation *
     * A list of cards (**ErrorCards**) that failed validation along with the appropriate error code
     * and message #### Asynchronous processing of valid API request * Move card requests that have
     * been submitted and processed will be reflected after midnight according to the customers
     * local date.
     * @param  apikey  Required parameter: This is the API key of the specific environment which
     *         needs to be passed by the client.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: Move cards request body.
     * @return    Returns the CardMoveResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public CardMoveResponse cardMove(
            final String apikey,
            final String requestId,
            final CardMoveRequest body) throws ApiException, IOException {
        return prepareCardMoveRequest(apikey, requestId, body).execute();
    }

    /**
     * This API allows to move one or more fuel cards (up to 500) across card groups within a single
     * account or across accounts under the same payer. If the API call succeeds, the API will
     * return a reference number and queue the request for asynchronous processing. #### Supported
     * operations * Moving card to exisitng card group * Moving card to new card group * Removing a
     * card from a card group #### Validation rules * Number of cards per request does not exceed
     * 500 * Given **PAN** for a card matches with only one card * A card is allowed to be moved to
     * the **TargetCardGroupId** or **TargetAccountNumber** * A pending move request does not exist
     * in the queue for a card submitted on the same date (customers local) * A card has not been
     * moved as part of a previous request on the same date (customers local) #### API response * A
     * main reference number for the API request (**MoveCardRequestReference**) * Individual
     * reference numbers (**MoveCardReference**) for each card move request that passes validation *
     * A list of cards (**ErrorCards**) that failed validation along with the appropriate error code
     * and message #### Asynchronous processing of valid API request * Move card requests that have
     * been submitted and processed will be reflected after midnight according to the customers
     * local date.
     * @param  apikey  Required parameter: This is the API key of the specific environment which
     *         needs to be passed by the client.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: Move cards request body.
     * @return    Returns the CardMoveResponse response from the API call
     */
    public CompletableFuture<CardMoveResponse> cardMoveAsync(
            final String apikey,
            final String requestId,
            final CardMoveRequest body) {
        try { 
            return prepareCardMoveRequest(apikey, requestId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for cardMove.
     */
    private ApiCall<CardMoveResponse, ApiException> prepareCardMoveRequest(
            final String apikey,
            final String requestId,
            final CardMoveRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<CardMoveResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.SHELL.value())
                        .path("/fleetmanagement/v1/card/move")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .headerParam(param -> param.key("apikey")
                                .value(apikey).isRequired(false))
                        .headerParam(param -> param.key("RequestId")
                                .value(requestId).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("BearerToken"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, CardMoveResponse.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("The server cannot or will not process the request  due to something that is perceived to be a client\r\n error (e.g., malformed request syntax, invalid \r\n request message framing, or deceptive request routing).",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("The request has not been applied because it lacks valid  authentication credentials for the target resource.",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("The server understood the request but refuses to authorize it.",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("The origin server did not find a current representation  for the target resource or is not willing to disclose  that one exists.",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("The server encountered an unexpected condition the prevented it from fulfilling the request.",
                                (reason, context) -> new ApiException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * This API allows requesting a PIN reminder for a fuel card. If the API call succeeds, the API
     * will return a reference number and queue the request for asynchronous processing. #### New
     * version updates * Oauth authentication to access the API * Change in request body where PIN
     * delivery type can be requested via Email, SMS or Post. PIN delivery contact can be set to
     * different values based on previous contact details of card or pin delivery or can set
     * specific contact details for this request. * PINAdviceType * PINContactType * PINDeliverTo *
     * Please note that we have a **savePINReminder** parameter in order to save the contact details
     * for future such requests. * Change in response body where Card details are also provided
     * along with expiry date and PAN details. #### Supported operations * Request a pin reminder by
     * card Id or PAN #### Validation rules * Given **PAN** or **CardId** is active * Given **PAN**
     * matches only one active card * Requested card has PIN * There is no pending PIN Reminder
     * request in the queue awaiting to be processed for the card * A PIN reminder request has not
     * been successfully processed in the last 48 hours for the card.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: PIN reminder request body
     * @return    Returns the PINReminderResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public PINReminderResponse cardPinReminder(
            final String requestId,
            final CardManagementV1PinreminderRequest body) throws ApiException, IOException {
        return prepareCardPinReminderRequest(requestId, body).execute();
    }

    /**
     * This API allows requesting a PIN reminder for a fuel card. If the API call succeeds, the API
     * will return a reference number and queue the request for asynchronous processing. #### New
     * version updates * Oauth authentication to access the API * Change in request body where PIN
     * delivery type can be requested via Email, SMS or Post. PIN delivery contact can be set to
     * different values based on previous contact details of card or pin delivery or can set
     * specific contact details for this request. * PINAdviceType * PINContactType * PINDeliverTo *
     * Please note that we have a **savePINReminder** parameter in order to save the contact details
     * for future such requests. * Change in response body where Card details are also provided
     * along with expiry date and PAN details. #### Supported operations * Request a pin reminder by
     * card Id or PAN #### Validation rules * Given **PAN** or **CardId** is active * Given **PAN**
     * matches only one active card * Requested card has PIN * There is no pending PIN Reminder
     * request in the queue awaiting to be processed for the card * A PIN reminder request has not
     * been successfully processed in the last 48 hours for the card.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: PIN reminder request body
     * @return    Returns the PINReminderResponse response from the API call
     */
    public CompletableFuture<PINReminderResponse> cardPinReminderAsync(
            final String requestId,
            final CardManagementV1PinreminderRequest body) {
        try { 
            return prepareCardPinReminderRequest(requestId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for cardPinReminder.
     */
    private ApiCall<PINReminderResponse, ApiException> prepareCardPinReminderRequest(
            final String requestId,
            final CardManagementV1PinreminderRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<PINReminderResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.SHELL.value())
                        .path("/card-management/v1/pinreminder")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .headerParam(param -> param.key("RequestId")
                                .value(requestId).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("BearerToken"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, PINReminderResponse.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing).",
                                (reason, context) -> new ErrorObjectException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("The request has not been applied because it lacks valid  authentication credentials for the target resource.",
                                (reason, context) -> new ErrorObjectException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("Forbidden",
                                (reason, context) -> new ErrorObjectException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("The origin server did not find a current representation  for the target resource or is not willing to disclose  that one exists.",
                                (reason, context) -> new ErrorObjectException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("The server encountered an unexpected condition that  prevented it from fulfilling the request.",
                                (reason, context) -> new ErrorObjectException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * This API allows scheduling Card Block / Unblock requests for one or multiple cards (up to 500
     * (configurable)) within a single API call. This API is used to perform the following Actions:
     * &gt; * AddOrUpdate (Schedule a new request or update an existing scheduled request for the
     * overlapping period. * AddAndOverwriteAll (all the existing requests of the given card will be
     * removed and a new request with the specified FromDate and ToDate will be added.) * Delete
     * (Deletes the scheduled request for the same From and To date) * DeleteAll (Deletes all the
     * scheduled requests for the given card) &gt; Requests that passed the below validations are
     * queue: * All Mandatory fields are passed in the request. * Card is present in the Shell Card
     * Platform. Only one matching card is available in the cards platform for the given PAN and
     * expiry date for the requests * The scheduled period start date or end date should be later
     * than or equal to the current date. &gt; If all validations are passed, the request will be
     * accepted and saved in the intermediate queue and the API will return reference numbers for
     * tracking purpose. &gt; A background service will execute the block/unblock requests on a daily
     * basis, based on the scheduled block or unblock date. * The newly added block/unblock request
     * will have a status ‘A’ when it is yet to be moved to the actual queue. * When the request is
     * moved to the actual queue table, the status will be updated as ‘P’ if the request has a value
     * for ‘ToDate’, else, the status will be updated as ‘S’ or ‘F’ based on whether the request has
     * been successfully moved to the actual queue table or if an error is encountered during
     * processing. * When the unblock request is moved to the actual queue table, the status of the
     * request will be changed from ‘P’ to ‘S’ or ‘F’ based on whether the request has been
     * successfully moved to the actual queue table or if an error has occurred during processing. &gt;
     * If any of the validations fail, the API will return the appropriate error details in the
     * response. &gt; The API response will include: * An error entity holding the details of any error
     * encountered. * A list of submitted cards along with the individual reference numbers for each
     * of the request.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: request body
     * @return    Returns the ScheduleCardBlockResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ScheduleCardBlockResponse scheduleCardBlock(
            final String requestId,
            final ScheduleCardBlockRequest body) throws ApiException, IOException {
        return prepareScheduleCardBlockRequest(requestId, body).execute();
    }

    /**
     * This API allows scheduling Card Block / Unblock requests for one or multiple cards (up to 500
     * (configurable)) within a single API call. This API is used to perform the following Actions:
     * &gt; * AddOrUpdate (Schedule a new request or update an existing scheduled request for the
     * overlapping period. * AddAndOverwriteAll (all the existing requests of the given card will be
     * removed and a new request with the specified FromDate and ToDate will be added.) * Delete
     * (Deletes the scheduled request for the same From and To date) * DeleteAll (Deletes all the
     * scheduled requests for the given card) &gt; Requests that passed the below validations are
     * queue: * All Mandatory fields are passed in the request. * Card is present in the Shell Card
     * Platform. Only one matching card is available in the cards platform for the given PAN and
     * expiry date for the requests * The scheduled period start date or end date should be later
     * than or equal to the current date. &gt; If all validations are passed, the request will be
     * accepted and saved in the intermediate queue and the API will return reference numbers for
     * tracking purpose. &gt; A background service will execute the block/unblock requests on a daily
     * basis, based on the scheduled block or unblock date. * The newly added block/unblock request
     * will have a status ‘A’ when it is yet to be moved to the actual queue. * When the request is
     * moved to the actual queue table, the status will be updated as ‘P’ if the request has a value
     * for ‘ToDate’, else, the status will be updated as ‘S’ or ‘F’ based on whether the request has
     * been successfully moved to the actual queue table or if an error is encountered during
     * processing. * When the unblock request is moved to the actual queue table, the status of the
     * request will be changed from ‘P’ to ‘S’ or ‘F’ based on whether the request has been
     * successfully moved to the actual queue table or if an error has occurred during processing. &gt;
     * If any of the validations fail, the API will return the appropriate error details in the
     * response. &gt; The API response will include: * An error entity holding the details of any error
     * encountered. * A list of submitted cards along with the individual reference numbers for each
     * of the request.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: request body
     * @return    Returns the ScheduleCardBlockResponse response from the API call
     */
    public CompletableFuture<ScheduleCardBlockResponse> scheduleCardBlockAsync(
            final String requestId,
            final ScheduleCardBlockRequest body) {
        try { 
            return prepareScheduleCardBlockRequest(requestId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for scheduleCardBlock.
     */
    private ApiCall<ScheduleCardBlockResponse, ApiException> prepareScheduleCardBlockRequest(
            final String requestId,
            final ScheduleCardBlockRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<ScheduleCardBlockResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.SHELL.value())
                        .path("/card-management/v1/schedulecardblock")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .headerParam(param -> param.key("RequestId")
                                .value(requestId).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("BearerToken"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ScheduleCardBlockResponse.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing).",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("The request has not been applied because it lacks valid  authentication credentials for the target resource.",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("Forbidden",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("The origin server did not find a current representation  for the target resource or is not willing to disclose  that one exists.",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("The server encountered an unexpected condition that  prevented it from fulfilling the request.",
                                (reason, context) -> new ApiException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * This API allows to update the reissue indicator of a single card. If the API call succeeds,
     * the API will return a reference number for tracking purposes and queue the request for
     * asynchronous processing. #### Supported operations * Update the reissue indicator of a card
     * to enable auto renewal * Update the reissue indicator of a card to disable auto renewal ####
     * Validation rules * Card status must be either Active, Temporary Block (Customer), Temporary
     * Block (Shell) or Pending Renewal, otherwise an error code 9016 is returned #### API response
     * * Returns a reference number for the API request (**AutoRenewReference**) #### Asynchronous
     * processing of valid API request * If the provided card is superseded i.e. a replacement/new
     * card is already issued, then the latest card's reissue indicator should be updated in the
     * Shell Card Platform. * Providing a **PAN** request paramter may result in multiple fuel cards
     * being located in the Shell Card Platform. The card details of the most recently issued card
     * will be considered.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: Auto renew request body
     * @return    Returns the AutoRenewCardResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public AutoRenewCardResponse autoRenew(
            final String requestId,
            final AutoRenewCardRequest body) throws ApiException, IOException {
        return prepareAutoRenewRequest(requestId, body).execute();
    }

    /**
     * This API allows to update the reissue indicator of a single card. If the API call succeeds,
     * the API will return a reference number for tracking purposes and queue the request for
     * asynchronous processing. #### Supported operations * Update the reissue indicator of a card
     * to enable auto renewal * Update the reissue indicator of a card to disable auto renewal ####
     * Validation rules * Card status must be either Active, Temporary Block (Customer), Temporary
     * Block (Shell) or Pending Renewal, otherwise an error code 9016 is returned #### API response
     * * Returns a reference number for the API request (**AutoRenewReference**) #### Asynchronous
     * processing of valid API request * If the provided card is superseded i.e. a replacement/new
     * card is already issued, then the latest card's reissue indicator should be updated in the
     * Shell Card Platform. * Providing a **PAN** request paramter may result in multiple fuel cards
     * being located in the Shell Card Platform. The card details of the most recently issued card
     * will be considered.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: Auto renew request body
     * @return    Returns the AutoRenewCardResponse response from the API call
     */
    public CompletableFuture<AutoRenewCardResponse> autoRenewAsync(
            final String requestId,
            final AutoRenewCardRequest body) {
        try { 
            return prepareAutoRenewRequest(requestId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for autoRenew.
     */
    private ApiCall<AutoRenewCardResponse, ApiException> prepareAutoRenewRequest(
            final String requestId,
            final AutoRenewCardRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<AutoRenewCardResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.SHELL.value())
                        .path("/card-management/v1/autorenew")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .headerParam(param -> param.key("RequestId")
                                .value(requestId).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("BearerToken"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, AutoRenewCardResponse.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing).",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("The request has not been applied because it lacks valid  authentication credentials for the target resource.",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("Forbidden",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("The origin server did not find a current representation  for the target resource or is not willing to disclose  that one exists.",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("The server encountered an unexpected condition that  prevented it from fulfilling the request.",
                                (reason, context) -> new ApiException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * This operation allows update the approval status of Mobile Payment Registration requests
     * requiring for Fleet Manager approval. If the approval status is: * “Approved” then the
     * request status will be changed to Pending for processing. * “Rejected” then status will be
     * updated to “CI” (Failed) with appropriate error message.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: Request body
     * @return    Returns the UpdateMPayRegStatusResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public UpdateMPayRegStatusResponse updateMobilePaymentRegistrationStatus(
            final String requestId,
            final UpdateMPayRegStatusRequest body) throws ApiException, IOException {
        return prepareUpdateMobilePaymentRegistrationStatusRequest(requestId, body).execute();
    }

    /**
     * This operation allows update the approval status of Mobile Payment Registration requests
     * requiring for Fleet Manager approval. If the approval status is: * “Approved” then the
     * request status will be changed to Pending for processing. * “Rejected” then status will be
     * updated to “CI” (Failed) with appropriate error message.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  body  Optional parameter: Request body
     * @return    Returns the UpdateMPayRegStatusResponse response from the API call
     */
    public CompletableFuture<UpdateMPayRegStatusResponse> updateMobilePaymentRegistrationStatusAsync(
            final String requestId,
            final UpdateMPayRegStatusRequest body) {
        try { 
            return prepareUpdateMobilePaymentRegistrationStatusRequest(requestId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for updateMobilePaymentRegistrationStatus.
     */
    private ApiCall<UpdateMPayRegStatusResponse, ApiException> prepareUpdateMobilePaymentRegistrationStatusRequest(
            final String requestId,
            final UpdateMPayRegStatusRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<UpdateMPayRegStatusResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.SHELL.value())
                        .path("/card-management/v1/updatemobilepaymentregistrationstatus")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .headerParam(param -> param.key("RequestId")
                                .value(requestId).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("BearerToken"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, UpdateMPayRegStatusResponse.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing).",
                                (reason, context) -> new ErrorObjectException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("The request has not been applied because it lacks valid  authentication credentials for the target resource.",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("Forbidden",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("The origin server did not find a current representation  for the target resource or is not willing to disclose  that one exists.",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("The server encountered an unexpected condition that  prevented it from fulfilling the request.",
                                (reason, context) -> new ApiException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Get a new public key that will be used to encrypt data for selected PIN process when ordering
     * new Shell Card. This encrypted data is used for further processing.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  fleet  Optional parameter: If the public key will be used a long time for multiple
     *         files this parameter will be true. If the parameter is true then public Key will be
     *         valid for 90 days. If the parameter is false then the key will be valid for one time.
     *         default value will be false.
     * @return    Returns the GeneratePINKeyResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public GeneratePINKeyResponse getKey(
            final String requestId,
            final Boolean fleet) throws ApiException, IOException {
        return prepareGetKeyRequest(requestId, fleet).execute();
    }

    /**
     * Get a new public key that will be used to encrypt data for selected PIN process when ordering
     * new Shell Card. This encrypted data is used for further processing.
     * @param  requestId  Required parameter: Mandatory UUID (according to RFC 4122 standards) for
     *         requests and responses. This will be played back in the response from the request.
     * @param  fleet  Optional parameter: If the public key will be used a long time for multiple
     *         files this parameter will be true. If the parameter is true then public Key will be
     *         valid for 90 days. If the parameter is false then the key will be valid for one time.
     *         default value will be false.
     * @return    Returns the GeneratePINKeyResponse response from the API call
     */
    public CompletableFuture<GeneratePINKeyResponse> getKeyAsync(
            final String requestId,
            final Boolean fleet) {
        try { 
            return prepareGetKeyRequest(requestId, fleet).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for getKey.
     */
    private ApiCall<GeneratePINKeyResponse, ApiException> prepareGetKeyRequest(
            final String requestId,
            final Boolean fleet) throws IOException {
        return new ApiCall.Builder<GeneratePINKeyResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.SHELL.value())
                        .path("/pin-management/v1/generatepinkeys")
                        .queryParam(param -> param.key("fleet")
                                .value(fleet).isRequired(false))
                        .headerParam(param -> param.key("RequestId")
                                .value(requestId).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("BearerToken"))
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, GeneratePINKeyResponse.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("The server cannot or will not process the request  due to something that is perceived to be a client\r\n error (e.g., malformed request syntax, invalid \r\n request message framing, or deceptive request routing).",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("The request has not been applied because it lacks valid  authentication credentials for the target resource.",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("The server understood the request but refuses to authorize it.",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("The origin server did not find a current representation  for the target resource or is not willing to disclose  that one exists.",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("The server encountered an unexpected condition the prevented it from fulfilling the request.",
                                (reason, context) -> new ApiException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * This API allows users to update the card’s delivery addresses (card delivery address used for
     * card re-issue and PIN delivery address used when PIN reminder is requested) #### Supported
     * operations * card delivery address update.
     * @param  apikey  Required parameter: This is the API key of the specific environment which
     *         needs to be passed by the client.
     * @param  body  Optional parameter: Delivery Address Update Request Body
     * @return    Returns the DeliveryAddressUpdateResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public DeliveryAddressUpdateResponse deliveryAddressUpdate(
            final String apikey,
            final DeliveryAddressUpdateRequest body) throws ApiException, IOException {
        return prepareDeliveryAddressUpdateRequest(apikey, body).execute();
    }

    /**
     * This API allows users to update the card’s delivery addresses (card delivery address used for
     * card re-issue and PIN delivery address used when PIN reminder is requested) #### Supported
     * operations * card delivery address update.
     * @param  apikey  Required parameter: This is the API key of the specific environment which
     *         needs to be passed by the client.
     * @param  body  Optional parameter: Delivery Address Update Request Body
     * @return    Returns the DeliveryAddressUpdateResponse response from the API call
     */
    public CompletableFuture<DeliveryAddressUpdateResponse> deliveryAddressUpdateAsync(
            final String apikey,
            final DeliveryAddressUpdateRequest body) {
        try { 
            return prepareDeliveryAddressUpdateRequest(apikey, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for deliveryAddressUpdate.
     */
    private ApiCall<DeliveryAddressUpdateResponse, ApiException> prepareDeliveryAddressUpdateRequest(
            final String apikey,
            final DeliveryAddressUpdateRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<DeliveryAddressUpdateResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.SHELL.value())
                        .path("/fleetmanagement/v1/card/deliveryaddressupdate")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .headerParam(param -> param.key("apikey")
                                .value(apikey).isRequired(false))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .withAuth(auth -> auth
                                .add("BasicAuth"))
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, DeliveryAddressUpdateResponse.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.setReason("The server cannot or will not process the request  due to something that is perceived to be a client\r\n error (e.g., malformed request syntax, invalid \r\n request message framing, or deceptive request routing).",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.setReason("The request has not been applied because it lacks valid  authentication credentials for the target resource.",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.setReason("The server understood the request but refuses to authorize it.",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.setReason("The origin server did not find a current representation  for the target resource or is not willing to disclose  that one exists.",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.setReason("The server encountered an unexpected condition the prevented it from fulfilling the request.",
                                (reason, context) -> new ApiException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }
}